## 목차

[2.2.1 HTTP 개요](#221-HTTP-개요)</br> [2.2.2 비지속 연결과 지속 연결](#222-비지속-연결과-지속-연결)</br> [2.2.3 HTTP 메시지 포맷](#223-HTTP-메시지-포맷)</br> [2.2.4 사용자와 서버 간의 상호작용: 쿠키 Cookie](#224-사용자와-서버-간의-상호작용:-쿠키-Cookie)</br> [2.2.5 웹 캐싱](#225-웹-캐싱)</br>

## 2.2.1 HTTP 개요

HTTP는 TCP를 전송 프로토콜로 사용한다. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다. 연결이 이루어지면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다. HTTP 서버는 클라이언트에 대한 정보를 유지하지 않으므로 HTTP를 비상태 프로토콜 stateless protocol 이라고 한다.

## 2.2.2 비지속 연결과 지속 연결

### 비지속 연결 HTTP non-persistent connection

웹 페이지가 기본 HTML파일과 10개의 JPEG 이미지로 구성되어있고 이 11개의 객체가 같은 서버에 있다고 가정할 때 연결 수행 과정은 다음과 같다.

1. HTTP 클라이언트는 HTTP의 포트 번호를 통해 도메인 서버로 TCP 연결을 시도함
2. HTTP 클라이언트는 1단계에서 설정된 TCP 연결 소켓을 통해 서버로 HTTP 요청을 보냄
3. HTTP 서버는 1단계에서 설정된 TCP 연결 소켓을 통해 요청 메시지를 받음 → HTTP 응답 메시지에 요청에 따른 컨텐츠 객체를 캡슐화 하여 소켓을 통해 응답함
4. HTTP 서버는 TCP에게 TCP 연결을 끊으라고함 (실제로는 클라이언트가 응답 메시지를 올바로 받을 때까지 연결을 끊지 않음)
5. HTTP 클라이언트는 응답 메시지를 받고 TCP 연결은 종료됨클라이언트는 응답 메시지로부터 파일을 추출하고 HTML파일을 조사하고 10개의 JPEG 객체에 대한 참조를 찾아 처음 4개의 단계를 반복함

HTTP는 클라이언트가 웹 페이지를 어떻게 해석하는지는 관심이 없고 클라이언트 HTTP 프로그램과 서버 HTTP 프로그램 사이의 프로토콜만 정의할 뿐이다.

위의 예에서는 11개의 TCP 연결이 만들어진다. 클라이언트는 10개의 순차적 TCP 연결을 통해 10개의 JPEG 파일을 얻을 수도 있고 아니면 동시에 TCP 연결을 여러개 만들어 JPEG를 얻을 수도 있다. 사용자는 브라우저 설정을 통해 동시성의 정도를 조절할 수 있다. 기본 모드에서 대부분의 브라우저는 5~10개의 TCP 연결을 동시에 설정하고 각 연결은 하나의 요청/응답 처리를 담당한다.

패킷이 클라이언트로부터 서버까지 가고 다시 클라이언트로 되돌아오는 데 걸리는 시간은 `RTT` (round-trip time) 이라고 한다. RTT는 패킷 전파지연, 중간 라우터와 스위치에서의 패킷 큐잉지연, 패킷 처리지연등을 포함한다.

클라이언트의 요청 시점에 브라우저가 브라우저와 웹 서버 사이에서 TCP 연결을 시도하고 이는 `“three-way handshake”`를 포함한다.

1. 클라이언트가 작은 TCP 메시지를 서버로 보낸다.
2. 서버는 작은 메시지로 응답한다. → 이 지점 까지의 두 부분이 경과하면 한 RTT가 계산된다.
3. 마지막으로 클아이언트가 다시 서버에게 응답한다. handshake의 두 과정이 끝난 후에 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 handshake의 세번째 부분(응답)을 함께 보낸다.

서버에 요청 메시지가 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다. 이 HTTP 요청/응답은 또 하나의 RTT를 필요로 한다.

### 지속 연결 HTTP

비지속 연결은 몇가지 단점이 있다.

1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다.

   TCP 버퍼가 할당되어야하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되어야 한다. 이는 수많은 다른 클라이언트의 요청을 동시에 서비스하는 웹 서버에게 심각한 부담이 될 수 있다.

2. 각 객체는 2RTT를 필요로 한다.

HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다. 같은 클라이언트와 서버간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 앞선 예시와 같이 11개의 객체에 대한 요구는 진행중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다.[파이프라이닝(pipelining)]

일반적으로 HTTP 서버는 일정기간(타임아웃 기간) 사용되지 않으면 연결을 닫는다. HTTP의 디폴트 모드는 파이프라이닝을 이용한 지속 연결을 사용한다. 최근에 HTTP/2 [RFC 7540]은 같은 연결상에서 다중요청과 응답이 가능하고 이 연결 내에서 HTTP 메시지 요청과 응답의 우선순위 기법이 가능하도록 제안되었다.

## 2.2.3 HTTP 메시지 포맷

### HTTP 요청 메시지

첫째 줄은 요청 라인 request line

- method 필드
- URL 필드
- HTTP 버전 필드

이후 줄들은 헤더라인 header line

- Host
  **_TCP 연결이 맺어있기 때문에 불필요할 수 있지만 호스트 헤더라인의 정보는 웹 프록시 캐시에서 필요로 한다._**
- Connection
  브라우저는 서버에게 지속 연결 사용을 원하지 않는다는 것을 말한다.
- User-agent
  서버에게 요청을 하는 브라우저 타입을 명시
- Accept-language
  객체의 언어 버전의 타입을 요청한다. 없다면 기본 버전을 보내고 콘텐츠 협상 헤더중 하나이다.

### HTTP 응답 메시지

첫째 줄은 요청 라인 request line

- method 필드
- URL 필드
- HTTP 버전 필드

이후 줄들은 헤더라인 header line

- Host
  **_TCP 연결이 맺어있기 때문에 불필요할 수 있지만 호스트 헤더라인의 정보는 웹 프록시 캐시에서 필요로 한다._**
- Connection
  브라우저는 서버에게 지속 연결 사용을 원하지 않는다는 것을 말한다.
- User-agent
  서버에게 요청을 하는 브라우저 타입을 명시
- Accept-language
  객체의 언어 버전의 타입을 요청한다. 없다면 기본 버전을 보내고 콘텐츠 협상 헤더중 하나이다.
- 개체 몸체 entity body

## 2.2.4 사용자와 서버 간의 상호작용: 쿠키 Cookie

서버는 상태를 유지하지 않지만, 서버가 사용자 접속을 제한하거나 사용자에 따라 다른 콘텐츠를 제공하기 하기 위해 웹 사이트가 사용자를 확인하는 것이 필요할 때가 있다. 이 목적으로 HTTP는 쿠키를 사용한다. [RFC 6265]

브라우저가 HTTP 응답 메시지를 받았을 때 그 ‘Set-cookie’ 헤더를 볼 수 있다. 그 다음 브라우저는 관리하는 특정한 쿠키 파일에 그 라인을 덧붙이게 된다. 추후 사용자가 사이트에 다시 접속하면 브라우저는 해당 사이트의 쿠키를 헤더 라인에 넣어 요청 메시지를 보내게 된다.

따라서 쿠키는 비상태HTTP 위에서 사용자 세션 계층을 생성하는데 이용될 수 있다. 하지만 사용자 사생활에 대한 침해로 보일 수 있음에 따라 논쟁거리이다.

## 2.2.5 웹 캐싱

웹 캐시 [Web cache; 프록시 서버(proxy server)라고도 함]는 원출처의 웹 서버 (origin web server)를 대신하여 HTTP 요구를 충족시키는 네트워크 개체이다. 웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다. 브라우저는 사용자의 모든 HTTP 요청이 웹 캐시에 가장 먼저 보내지도록 구성될 수 있다.

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본의 저장여부를 확인하고 브라우저로 HTTP 응답 메시지와 함께 객체를 응답한다.
3. 객체가 없다면 웹 캐시는 origin web server로 TCP 연결을 설정한다. 이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 HTTP 요청을 보낸다.
4. 서버로부터 HTTP 응답 메시지와 객체를 받은 웹 캐시는 자신의 로컬 저장장치에 복사하고 브라우저에 객체의 사본을 (브라우저와 웹캐시 사이에 설정된 TCP 연결을 통해) 보낸다.

장점

- 요청에 대한 **_응답 시간_**을 줄일 수 있다
- 한 기관에서 인터넷으로 접속하는 링크상의 **_웹 트래픽_**을 줄일 수 있다 → 비용, 성능 개선 가능

캐시는 서버이면서 클라이언트이다. 일반적으로 웹 캐시는 ISP가 구입하고 설치한다. 캐시의 가격은 저렴하다. 많은 캐시들이 저렴한 PC에서 실행되는 공개 소프트웨어를 사용한다. **_콘텐츠 전송 네트워크_** (CDN, Content Distribution Network)의 사용을 통해, 웹 캐시는 인터넷에서 중요한 역할을 하고 있다. CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며 이로 이내 많은 트래픽을 지역화 하고있다.

### 조건부 GET

웹 캐싱은 새로운 문제를 야기한다. 캐시 내부의 객체 사본이 최신이 아닐 수 있다. HTTP는 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 갖고있다. 이 방식을 조건부 GET (conditional GET) 이라고 한다. HTTP 요청 메시지가 GET 방식을 사용하고 IF-Modified-Since 헤더라인을 포함하고 있다면 그것이 조건부 GET 메시지이다. 조건부 GET은 다음과 같이 동작한다.

1. 최초 브라우저의 요청 발생 → 프록시 캐시는 요청 메시지를 웹 서버로 보냄
2. 웹 서버는 캐시에게 객체를 포함한 응답 메시지를 전달함
3. 캐시는 객체의 원본을 저장하고 더불어 마지막으로 수정된 날짜 Last-Modified 를 함께 저장하고 사본을 브라우저에 응답한다.
4. 시간이 지나고 브라우저가 같은 객체를 요청하면 브라우저는 조건부 GET으로 갱신 조사를 수행한다. IF-modified-since 헤더 라인의 값이 Last-Modified의 값과 일치하는지 확인한다.

   이 조건부 GET은 서버에게 그 객체가 명시된 날짜 이후 수정된 경우에만 그 객체를 보낼것을 요구한다. 수정되지 않았다면 서버는 객체 없이(빈 개체 몸체로) 응답 메시지만 캐시에 보내고

5. 캐시는 서버의 응답 메시지에 따라 객체의 사본을 브라우저에 응답한다.
