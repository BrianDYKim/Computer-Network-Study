## 목차

[3.3.0 개요](#330-개요)</br> [3.3.1 UDP 세그먼트 구조](#331-UDP-세그먼트-구조)</br> [3.3.2 UDP 체크섬](#332-UDP-체크섬)</br>

## 3.3.0 개요

[RFC 768]에서 정의된 UDP는 트랜스포트 계층 프로토콜이 할 수 있는 최소기능으로 동작한다. 즉, 다중화/역다중화 기능, 간단한 오류검사기능 외에는 IP에 아무것도 추가하지 않는다. UDP를 사용하는 대표적인 사례인 DNS는 다음과 같이 작동한다.

1. 호스트 애플리케이션의 DNS질의 메시지 생성
2. DNS질의 메시지 작성 후 UDP에게 메시지 전달
3. 메시지 헤더필드를 추가한 후 최종 세그먼트를 하위인 네트워크 계층에 전달
4. 네트워크 계층은 UDP 데이터그램을 캡슐화하고 네임서버에 데이터그램을 송신함
5. 호스트 애플리케이션은 DNS질의에 대한 응답을 기다림

UDP의 특징과 함께, UDP의 장점을 엿볼 수 있다.

1. <u>데이터 전송에 대한 애플리케이션 레벨에서의 더 정교한 제어가 가능하다.</u> 애플리케이션 프로세스가 데이터를 UDP에 전달하자마자 UDP는 데이터를 데이터그램화 하여 즉시 네트워크 계층으로 전달한다. 실시간 애플리케이션과 같은 서비스는 서비스의 특성상 UDP의 서비스의 모델에 적합하다. TCP의 경우 혼잡제어 메커니즘, 신뢰적 전달보장을 위한 지연등의 소요가 있기 때문이다. UDP의 기본적인 기능인 세그먼트 전달 외에 필요한 추가기능이 있다면 애플리케이션 레벨에서 구현할 수 있을 것이다.
2. 앞서 언급했다 시피 <u>연결에 대한 설정이 없다.</u> 따라서 연결설정을 위한 지연이 없다.
3. <u>연결 상태가 없다.</u> TCP는 신뢰적 전달과 혼잡제어 기능을 위해 종단시스템에서 연결상태를 유지하는 반면 UDP는 연결상태를 유지하지 않으며 서버가 좀 더 많은 클라이언트를 수용할 수 있다.
4. <u>패킷과 헤더의 오버헤드가 작다.</u> TCP가 세그먼트마다 20바이트의 헤더 오버헤드를 갖는 반면 UDP는 8바이트 뿐이다.

오늘날의 멀티미디어 애플리케이션을 UDP 위에서 동작시키는 방법이 일반적이긴 하지만 아직 논의의 여지가 있다. 앞서 언급한 것처럼 UDP는 혼잡제어 기능이 없다. 그러나 혼잡제어는 네트워크가 폭주상태에 빠지는 것을 막기위해 필요하다. **만약 모두가 혼잡제어를 사용하지 않고 높은 비트의 비디오 스트리밍을 시작한다면, 라우터에서 많은 패킷 오버플로가 발생할 것이고 이는 소수의 UDP 패킷만이 출발지-목적지 간의 경로 통신이 될 것이다.** 또한 무엇보다도 **제어되지 않은 UDP 송신자에 의해 발생된 높은 손실률은 그 손실률을 감소시키기 위해 TCP 송신자들이 속도를 줄이도록 한다.** 그러므로 UDP 의 혼잡제어의 결여는 UDP 송신자와 수신자간의 높은 손실률을 초래할 수 있고 TCP 세션을 줄이기도 한다. (잠재적인 문제점)

UDP를 사용할 떄에도 신뢰적인 데이터 전송이 가능하기는 하다. 만약 애플리케이션이 신뢰성을 애플리케이션 자체에서 제공한다면 가능하다. (다음절에서 알아볼 확인응답 메커니즘과 재전송 메커니즘 추가 등). 구글의 크롬 브라우저에서 사용되는 QUIC ( Quick UDP Internet Connections )프로토콜은 UDP상에서 애플리케이션 계층에 신뢰성을 구현하였다. 그러나 이것은 애플리케이션 개발자에게 어려운 작업이다.

## 3.3.1 UDP 세그먼트 구조

애플리케이션 데이터는 UDP 데이터그램의 데이터 필드에 위치한다. UDP 헤더는 2바이트씩 구성된 4개의 필드를 가진다. 체크섬은 세그먼트에 오류가 발생했는지 검사하기 위해 수신 호스트에 의해서 사용된다. 또한 UDP 세그먼트 이외에 IP 헤더의 일부 필드도 계산한다.

길이 필드는 헤더를 포함하는 UDP 세그먼트의 길이(바이트 단위)를 나타낸다.

## 3.3.2 UDP 체크섬

UDP 체크섬은 오류검출을 제공한다. 체크섬은 세그먼트가 출발지로부터 목적지로 이동했을 때 (링크의 잡음에 의해서 또는 라우터에서 저장되는 동안) UDP 세그먼트 안의 비트에 대한 변경사항이 있는지 검사한다.

1. 세그먼트 안의 데이터를 16비트 단위로 분할한다.
2. 분할된 각 16비트 데이터를 더한다.
3. 덧셈 과정에서 발생하는 오버플로는 윤회식 자리올림한다.
4. 합의 1의 보수를 한다.

이 결과값이 체크섬 필드에 삽입된다. 수신자에서는 체크섬을 포함한 모든 16비트들이 더해진다. 만약 패킷에 어떤 오류도 있지 않다면 수신자에서의 합은 1111111111111111이 될것이다. 만약 비트 중에서 하나라도 0이 있다면 패킷에 오류가 발생했음을 알 수 있다.

많은 링크계층 프로토콜(인기있는 이더넷 프로토콜 포함)이 오류검사를 제공하는데 왜 UDP가 체크섬을 굳이 제공할까. 그 이유는 출발지-목적지 사이의 모든 링크가 오류검사를 제공한다는 보장이 없다. 따라서 세그먼트들이 정확하게 링크를 통해 전송되었을지라도 세그먼트가 라우터 메모리에 저장될 때 비트오류가 들어오는 것이 가능하다. 주어진 링크간의 신뢰성과 메모리의 오류검사가 보장되지 않기 때문에 종단간의 데이터 전송 서비스가 오류검사를 제공한다면, UDP는 종단간의 트랜스포트 계층에서 오류검사를 제공해야만 한다. 이것이 시스템설계에서의 그 유명한 종단간의 원리 (end-end principle)의 한 예다. 즉, “어떤 기능이(이 경우엔 오류검사) 종단 기반으로 구현해야 하므로, 하위 레벨에 위치한 기능들은 상위 레벨에서 이들을 제공하는 비용을 비교했을 때 중복되거나 거의 유용하지 않을 수 있다.”
